This project is your “editor-mode” implementation of **deMeza AutoCSS**: a small Flask site plus a front-end layout system that demonstrates (and stress-tests) your tile philosophy. The goal is to make page layout feel “inevitable” rather than handcrafted—so desktop and mobile versions emerge automatically from a few rules, and you spend your time building features instead of fighting responsive CSS.

At the back end we kept things deliberately simple: a single Flask app with routes for the different templates (`/`, `/classic`, `/workspace`, `/game`) and a static route. You also wanted loud startup and route logging so you can see exactly what’s happening as soon as the server boots and on every request. That logging is helpful on PythonAnywhere too, because it lets you confirm routing and template rendering without guesswork.

On the front end, the real work was defining and stabilizing the **deMeza tile system** and getting the “three templates cover 99% of needs” approach into a working, repeatable structure:

1. **Classic template**
   This is the “original demo” page: it shows the standard tile grid, a stretch tile, ghost tiles for centering, and a handful of example UI tiles (mailing list input, sliders, file upload, textarea, and the arrow-linked steps). The Classic page also includes your “simulator” controls, letting you emulate different widths inside the device frame. This is important because it makes layout debugging deterministic and visible without constantly resizing a real browser window.

2. **Workspace template**
   This is the first “special tile” behavior you introduced: a workspace tile that dominates the layout and *ignores anything after it*. You described it like “Figma/Photoshop”—it should expand to the maximum possible space while respecting the top menu bars. Instead of lots of tiles, Workspace is mostly a canvas area ready for nodes and custom UI elements. The key technical detail was making it fill the remaining space reliably without micro-scroll, including handling the simulator frame height, sticky headers, padding, and small rounding errors.

3. **Game template**
   Game is essentially Workspace with one critical difference on mobile: it uses a “rotate to play” gate. On desktop it behaves like the workspace canvas. On mobile portrait it blocks interaction and asks the user to rotate to landscape, so the game can run in a usable orientation. This sets up your “mini desktop-like game view on phones” idea without building two separate layouts.

To support those templates, we organized a small but structured client-side architecture under a `window.Demeza` namespace (which you later corrected to **deMeza** as the brand spelling). You put everything in `static/js` initially, which was fine for speed, and then we started extracting shared components so the HTML templates became thinner and easier to maintain.

The shared JavaScript pieces we set up included:

* **log.js**: a consistent timestamped logger so every UI interaction and lifecycle event is traceable. This is foundational for your workflow: you want to be able to follow a “what happened first?” sequence in the console at any time.
* **layout_bus.js**: a simple pub/sub bus so layout-sensitive systems can respond when something changes (hamburger opens, simulator width changes, rotate gate toggles, etc.). This prevents brittle “call update from everywhere” spaghetti.
* **device.js**: device detection helpers. We used UAParser if available, and also fallbacks like pointer-coarse and UA hints. The intent is to treat “native mobile” as a first-class mode, not just a small screen.
* **nav_ui.js**: the top navigation behavior, especially the hamburger toggle, aria attributes, and click logging.
* **simulator.js**: the device-frame resizing slider and buttons (mobile/desktop width presets + live view). This drives layout changes and notifies the LayoutBus.
* **workspace_input.js**: basic pointer and wheel input logging for the workspace canvas. Even before building real node interactions, it proves input works and creates a clean place to expand.
* **workspace_system.js**: the sizing engine that makes the workspace tile reliably fill the available vertical space. This is where we handled the tricky bits like “no micro scroll,” integer sizing, and accounting for header height and grid padding.
* **rotate_gate.js**: the mobile portrait blocker overlay for the game template. It listens for resize/orientation changes and toggles a full overlay when portrait is detected.
* **index.js / index_boot.js / game_boot.js**: small “boot” scripts that initialize the relevant subsystems per page.

A big theme this session was **stability and debuggability**. You didn’t just want it to “work”; you wanted it to be predictable and easy to diagnose. So almost every user interaction (slider input, button click, nav toggle, pointerdown/move/up on canvas) logs to console with a consistent prefix. Likewise, layout changes are centralized: the simulator changes width, it notifies LayoutBus, and the workspace system reacts. That structure will matter a lot once you start adding real canvas UI (node editors, selection rectangles, pan/zoom, context menus, etc.).

We also dealt with a small but real layout bug: the “bottom padding pop” / micro-scroll effect in narrow views. The fix strategy was: remove unnecessary scrolling on workspace pages, compute heights in integer space, add a tiny “fudge” pixel to prevent rounding from creating 1px overflow, and forcibly reset scrollTop if anything tries to scroll. That’s the kind of pragmatic engineering that keeps the system feeling solid.

Another major change was **moving shared CSS into `static/css`**. Initially Classic and Workspace had huge inline style blocks. You decided that while your “baked final design” might keep everything embedded, this project is acting as an “editor” and is allowed to use external CSS/JS. So we extracted the common styling—tokens, simulator frame, header bars, tile grid logic, tile rules, inputs, sliders, and live view behavior—into a shared CSS file (`demeza_base.css`). That reduces duplication and ensures Classic/Workspace/Game stay visually consistent as you iterate.

We briefly experimented with changing the hamburger menu to overlay (float over content with ~90% opacity) instead of pushing content down. You tested it, then later chose to **revert to the old push-down behavior**, and you explicitly reverted the base CSS back. The final outcome from that decision is that the hamburger menu once again behaves exactly like before: it expands the nav area and pushes content downward on mobile.

Finally, you tightened branding: you want the spelling consistently as **deMeza**, not “Demeza.” You also asked for index and game improvements: “unlock” game.html (stop marking it as TBA), and make the footer year dynamic via JavaScript (so “2025” automatically updates each year). Those are simple refinements but they show the direction: you’re turning a prototype menu into a real landing hub for your three-template system.

In short, this session moved the project from “prototype HTML blobs” toward a maintainable **template + shared assets** architecture, with strong console observability, a robust workspace sizing system, and a clear separation between Classic (tile demo), Workspace (canvas/editor), and Game (workspace + rotate gate).
19-DEC-2025

---------------------------------------------------------------------------------------------------------------------------------------------------------------------

In this session, we significantly refined the "deMeza AutoCSS" project, focusing on user navigation, layout stability, and visual differentiation between templates. The work touched upon HTML structure, CSS styling, and core JavaScript logic to resolve bugs and enhance the simulator's realism.

Here is a breakdown of the key accomplishments:

**1. Navigation and Social Integration**
We started by improving the project's connectivity and navigation flow.

* **"Buy Me a Coffee" Link:** We updated `templates/index.html` to include a footer link pointing to `buymeacoffee.com/viralkiller`, ensuring it matched the existing aesthetic.
* **"Back to Index" Button:** We implemented a consistent "Back" button (an arrow icon) in the top-left corner of `classic.html`, `workspace.html`, and `game.html`. This allows users to easily return to the main menu.
* **Live View Logic:** Crucially, we added styles to `demeza_base.css` to hide this back button (along with the simulator controls) when "Live View" is toggled. This ensures that when a user wants to preview the "native app" experience, the UI is clean and distraction-free.

**2. Resolving CSS 404 Errors**
A major layout bug was identified where the Workspace and Game canvases were failing to span the full width of the desktop screen.

* **Diagnosis:** The templates were referencing a non-existent file named `demeza_workspace.css`.
* **Fix:** We corrected the links in `templates/workspace.html` and `templates/game.html` to point to the correct files (`workspace.css` and `game.css`). This restored the `grid-column: 1 / -1` property, allowing the main canvas tiles to properly dominate the layout as intended.

**3. Grid Precision and Padding Enforcement**
We implemented two scripted solutions to polish the visual presentation.

* **Perfect Grid Squares:** In `static/js/workspace_system.js`, we replaced the static background grid with a dynamic calculation. The script now measures the exact width of the canvas and calculates a grid size that divides perfectly into that width. This ensures that the grid lines always align cleanly with the container edges, eliminating ugly partial squares.
* **Symmetry Enforcement:** To prevent the layout from "popping" or looking uneven, we added a `fixPadding()` function to `static/js/simulator.js`. This function reads the browser's computed `padding-left` for the body and strictly enforces the exact same value for `padding-bottom`. This guarantees a symmetrical frame around the device simulator.

**4. Fixing the "Off-Screen" Vertical Overflow**
We addressed a critical issue where the bottom of the workspace frame was being pushed off-screen in Live View.

* **The Issue:** Setting the frame height to `100vh` ignored the body's padding, causing the total height to exceed the viewport.
* **The Solution:** We updated the resize logic in `workspace_system.js`. In Live View, the height is now calculated as `calc(100vh - (paddingTop + paddingBottom))`. This ensures the device frame is always 100% visible without requiring the user to scroll to see the bottom border.

**5. Differentiating the Game Template**
Finally, we gave the Game template a distinct identity separate from the Workspace.

* **Visual Logic:** We added a `template-game` class to `templates/game.html`.
* **Dynamic Iconography:** We updated `workspace_system.js` to detect this class. When present, it disables the grid lines and instead renders a large, faint Gamepad SVG icon in the center of the canvas.
* **Orientation Simulation:** The script now checks the aspect ratio of the container. If the game is in "Portrait" mode (taller than wide), the gamepad icon rotates 90 degrees. This simulates a "wrong orientation" state, visually prompting the user to rotate their device (or the simulator) to Landscape mode to play.

Since the last report, our primary focus has been debugging a persistent layout instability where the Workspace and Game templates would "pop" or overflow the viewport bottom during simulator adjustments (slider dragging or mode toggles).

**1. Diagnosing the "Pop"**
We identified that while the "Live View" (full screen) worked perfectly, the **Simulator Mode** was calculating available height incorrectly. The logic was setting the device frame height based on the full viewport, failing to account for the **Simulator Toolbar** (`.controls`) at the top of the page. This caused the bottom of the device frame to be pushed off-screen by exactly the height of that toolbar.

**2. The "Enforcer" Experiment**
To fix this, we initially implemented a strict "Layout Enforcer" script in `layout_bus.js`. This script monitored the DOM every 16ms and forcibly corrected margins and heights if it detected an overflow.

* **Result:** While it technically stopped the overflow, it introduced significant visual **jitter**. The JavaScript correction loop was fighting against the smooth CSS transitions (0.2s animations), causing the layout to shake visibly during resizing.

**3. The Final Solution: Targeted Logic**
We discarded the "Enforcer" approach to restore smoothness and implemented a cleaner, logic-based fix within `workspace_system.js`:

* **Reverted `layout_bus.js`:** We stripped out the complex monitoring code, returning the bus to its original, lightweight state.
* **Updated `workspace_system.js`:** We rewrote the `fit()` function with two distinct logic paths:
* **Live Mode:** Continues to use `calc(100vh - padding)` for a full-screen immersive experience.
* **Simulator Mode:** Now explicitly measures the height of the `.controls` toolbar. It calculates the frame height as:
`Viewport - Toolbar Height - Padding - Safety Buffer (12px)`.



This approach solves the root cause (ignoring the toolbar) rather than trying to patch the symptoms, ensuring the bottom border remains visible and the layout remains stable without any jitter.


19-DEC-2025
---------------------------------------------------


